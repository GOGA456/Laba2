section .data               ; Секция данных (константы и переменные)
    number dd 1234          ; Определяем число (dd = 32-битное целое)
    format db "Sum: %d, Product: %d, |Sum - Product|: %d", 10, 0  ; Строка формата для вывода

section .text               ; Секция кода
    global main             ; Делаем main видимой для линкера
    extern printf           ; Объявляем внешнюю функцию printf

main:                       ; Главная функция
    push rbp                ; Сохраняем базовый указатель стека
    mov rbp, rsp            ; Устанавливаем новый базовый указатель
    sub rsp, 32             ; Выделяем 32 байта в стеке для локальных переменных

    ; Вычисление суммы цифр
    mov eax, [number]       ; Загружаем число в регистр eax (хранит число при вычислениях)
    call sum_digits         ; Вызываем функцию суммы цифр
    mov [rbp-4], eax        ; Сохраняем результат суммы в стеке

    ; Вычисление произведения цифр
    mov eax, [number]       ; Снова загружаем число
    call product_digits     ; Вызываем функцию произведения цифр
    mov [rbp-8], eax        ; Сохраняем результат произведения в стеке

    ; Вычисление модуля разности
    mov eax, [rbp-4]        ; Загружаем сумму
    sub eax, [rbp-8]        ; Вычитаем произведение (sum - product)
    cdq                     ; Расширяем знак eax в edx (для отрицательных чисел)
    xor eax, edx            ; Побитовый XOR (инвертирует если число отрицательное)
    sub eax, edx            ; Получаем модуль числа
    mov [rbp-12], eax       ; Сохраняем модуль разности в стеке

    ; Подготовка аргументов для printf
    mov rcx, [rbp-12]       ; 4-й аргумент: модуль разности
    mov rdx, [rbp-8]        ; 3-й аргумент: произведение
    mov rsi, [rbp-4]        ; 2-й аргумент: сумма
    mov rdi, format         ; 1-й аргумент: строка формата
    xor eax, eax            ; Обнуляем eax (для variadic функций)
    call printf             ; Вызываем printf

    ; Завершение программы
    mov rsp, rbp            ; Восстанавливаем указатель стека
    pop rbp                 ; Восстанавливаем базовый указатель
    xor eax, eax            ; Возвращаем 0 (успешное завершение)
    ret                     ; Выход из функции

; Функция вычисления суммы цифр
sum_digits:
    xor ebx, ebx            ; Обнуляем ebx (здесь будет сумма)
    mov ecx, 10             ; Устанавливаем делитель (10 для десятичной системы)
.sum_loop:
    xor edx, edx            ; Обнуляем edx перед делением
    div ecx                 ; Делим eax на 10: eax = частное, edx = остаток (цифра)
    add ebx, edx            ; Добавляем цифру к сумме
    test eax, eax           ; Проверяем, осталось ли число
    jnz .sum_loop           ; Если не ноль, продолжаем цикл
    mov eax, ebx            ; Возвращаем сумму через eax
    ret                     ; Выход из функции

; Функция вычисления произведения цифр
product_digits:
    mov ebx, 1              ; Инициализируем ebx единицей (здесь будет произведение)
    mov ecx, 10             ; Устанавливаем делитель
.product_loop:
    xor edx, edx            ; Обнуляем edx перед делением
    div ecx                 ; Делим eax на 10
    imul ebx, edx           ; Умножаем произведение на цифру (остаток)
    test eax, eax           ; Проверяем, осталось ли число
    jnz .product_loop       ; Если не ноль, продолжаем цикл
    mov eax, ebx            ; Возвращаем произведение через eax
    ret                     ; Выход из функции
